"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compilePrompt = void 0;
const handlebars_1 = __importDefault(require("handlebars"));
const utils_1 = require("../../vision/utils");
const DEFAULT_MODEL_PROVIDER = "openai";
class SectionManager {
    sections = {};
    getSection(name) {
        return this.sections[name] || "";
    }
    setSection(name, content) {
        this.sections[name] = content;
    }
    getAllSections() {
        return this.sections;
    }
}
const IMAGE_TOKEN_PREFIX = "[[[HANDLEBARS_IMAGE:";
const IMAGE_TOKEN_SUFFIX = "]]]";
function createHandlebarsEnv() {
    const HandlebarsEnv = handlebars_1.default.create();
    const sectionManager = new SectionManager();
    HandlebarsEnv.registerHelper("section", function (name, options) {
        const content = options.fn(this);
        sectionManager.setSection(name, content);
        return ""; // don't output anything in place
    });
    HandlebarsEnv.registerHelper("image", function (imageParam) {
        const tokenPayload = JSON.stringify({ url: imageParam });
        // Use encodeURIComponent to avoid conflicts with special characters.
        const token = `${IMAGE_TOKEN_PREFIX}${encodeURIComponent(tokenPayload)}${IMAGE_TOKEN_SUFFIX}`;
        return token;
    });
    HandlebarsEnv.registerHelper("images", function (imagesParam) {
        if (!Array.isArray(imagesParam))
            return "";
        return imagesParam
            .map((url) => {
            const tokenPayload = JSON.stringify({ url });
            return `${IMAGE_TOKEN_PREFIX}${encodeURIComponent(tokenPayload)}${IMAGE_TOKEN_SUFFIX}`;
        })
            .join("");
    });
    return { HandlebarsEnv, sectionManager };
}
function processSectionContent(content, imageDetail) {
    if (!content.includes(IMAGE_TOKEN_PREFIX)) {
        return content.trim();
    }
    const segments = [];
    const regex = /\[\[\[HANDLEBARS_IMAGE:(.*?)\]\]\]/g;
    let lastIndex = 0;
    let match;
    while ((match = regex.exec(content)) !== null) {
        // Get the text before the token.
        const textPart = content.slice(lastIndex, match.index).trim();
        if (textPart) {
            segments.push({ type: "text", text: textPart });
        }
        // Decode the token payload.
        try {
            const payloadJson = decodeURIComponent(match[1]);
            const payload = JSON.parse(payloadJson);
            if (imageDetail) {
                segments.push({
                    type: "image_url",
                    image_url: { url: payload.url, detail: imageDetail },
                });
            }
            else {
                segments.push({
                    type: "image_url",
                    image_url: { url: payload.url },
                });
            }
        }
        catch (err) {
            // If decoding/parsing fails, treat the token as literal text.
            segments.push({ type: "text", text: match[0] });
        }
        lastIndex = match.index + match[0].length;
    }
    const remaining = content.slice(lastIndex).trim();
    if (remaining) {
        segments.push({ type: "text", text: remaining });
    }
    return segments;
}
function compilePrompt(promptTemplate, params, options) {
    const { HandlebarsEnv, sectionManager } = createHandlebarsEnv();
    const template = HandlebarsEnv.compile(promptTemplate, { noEscape: true });
    template(params);
    const sections = sectionManager.getAllSections();
    // TODO: system cannot have images, we can add validation for that
    const system = sections["system"];
    const user = sections["user"];
    if (!system || !user) {
        // TODO: support templates that have only one section
        throw new Error("Both system and user sections must be defined in the template");
    }
    const systemContent = processSectionContent(system);
    const userContent = processSectionContent(user, options?.imageDetail);
    let userContentCorrectedForImageFormat = userContent;
    if (Array.isArray(userContent)) {
        const provider = options?.modelProvider || DEFAULT_MODEL_PROVIDER;
        userContentCorrectedForImageFormat = userContent.map((c) => {
            if (c.type === "image_url") {
                return {
                    ...c,
                    image_url: {
                        ...c.image_url,
                        url: (0, utils_1.imageFormatForProvider)(provider, c.image_url.url),
                    },
                };
            }
            else {
                return c;
            }
        });
    }
    return [
        { role: "system", content: systemContent },
        { role: "user", content: userContentCorrectedForImageFormat },
    ];
}
exports.compilePrompt = compilePrompt;
