"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerInfoStore = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("../utils");
class WorkerInfoStore {
    basePath;
    constructor() {
        this.basePath = (0, utils_1.basePath)();
    }
    async saveWorkerToDisk(idx, contents) {
        if (!fs_1.default.existsSync(this.basePath)) {
            fs_1.default.mkdirSync(this.basePath, { recursive: true });
        }
        // TODO: can we make this file path unique for a session?
        // will avoidd ios/android running into issues when running concurrently on local
        fs_1.default.writeFileSync(path_1.default.join(this.basePath, `worker-info-${idx}.json`), JSON.stringify(contents, null, 2));
    }
    async getWorkerFromDisk(idx) {
        const filePath = path_1.default.join(this.basePath, `worker-info-${idx}.json`);
        if (!fs_1.default.existsSync(filePath)) {
            return undefined;
        }
        return JSON.parse(fs_1.default.readFileSync(filePath, "utf-8"));
    }
    async getWorkerStartTime(idx) {
        const info = await this.getWorkerFromDisk(idx);
        if (!info || !info.startTime) {
            throw new Error(`Worker start time info is not available.`);
        }
        return new Date(info.startTime.afterAppiumSession);
    }
    async saveWorkerStartTime(idx, sessionId, providerName, beforeAppiumSession, afterAppiumSession) {
        let info = await this.getWorkerFromDisk(idx);
        const delta = {
            providerName,
            sessionId,
            startTime: {
                beforeAppiumSession: beforeAppiumSession.toISOString(),
                afterAppiumSession: afterAppiumSession.toISOString(),
            },
        };
        if (!info) {
            info = {
                ...delta,
                idx,
                tests: [],
            };
        }
        else {
            info = {
                ...info,
                ...delta,
            };
        }
        return this.saveWorkerToDisk(idx, info);
    }
    async saveWorkerEndTime(idx, endTime) {
        let info = await this.getWorkerFromDisk(idx);
        if (!info) {
            throw new Error(`Worker info not found for idx: ${idx}`);
        }
        info.endTime = endTime.toISOString();
        return this.saveWorkerToDisk(idx, info);
    }
    async saveTestStartTime(idx, testTitle, startTime) {
        let info = await this.getWorkerFromDisk(idx);
        if (!info) {
            info = {
                idx,
                tests: [{ title: testTitle, startTime: startTime.toISOString() }],
            };
        }
        else {
            info.tests.push({
                title: testTitle,
                startTime: startTime.toISOString(),
            });
        }
        return this.saveWorkerToDisk(idx, info);
    }
}
exports.WorkerInfoStore = WorkerInfoStore;
