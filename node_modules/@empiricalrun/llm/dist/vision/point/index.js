"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLlmResponse = exports.extractTapCoordinateFromString = exports.getCoordinatesFor = void 0;
const async_retry_1 = __importDefault(require("async-retry"));
const trace_1 = require("../../trace");
const image_1 = require("../image");
const utils_1 = require("../utils");
const cache_1 = require("./cache");
const API_BASE_URL = "https://api.empirical.run/vision";
/**
 * Call the vision model to get the coordinates for a prompt. Set `useCache` to
 * true if you are clicking on a fixed UI element multiple times. Caching uses `prompt`
 * and dimensions of the `base64Image` to store the coordinates.
 */
async function getCoordinatesFor(prompt, base64Image, options) {
    let scaledPoint;
    if (options?.useCache) {
        const cachedPoint = (0, cache_1.getFromCache)(prompt, base64Image);
        if (cachedPoint) {
            // Cache works if prompt and image dimensions are the same
            console.log(`Cache hit for prompt: ${prompt}`);
            scaledPoint = cachedPoint;
        }
    }
    if (!scaledPoint) {
        if (options?.telemetry?.tags && !trace_1.langfuseInstance) {
            console.warn("Telemetry keys are not set. Telemetry will not be sent.");
        }
        const session = (0, utils_1.getSessionDetails)();
        const trace = trace_1.langfuseInstance?.trace({
            name: "vision-point",
            sessionId: session.id,
            release: session.version,
        });
        trace?.update({
            tags: ["vision", "vision-point", ...(options?.telemetry?.tags ?? [])],
            input: {
                base64Image,
                prompt,
            },
        });
        const generationTrace = trace?.generation({
            name: "get-coordinates-for",
            model: "Molmo-7B-D-0924",
            input: {
                userMessages: {
                    prompt,
                    image: base64Image,
                },
            },
        });
        const llmResponse = await getLlmResponse(base64Image, prompt);
        const pointFromLlm = extractTapCoordinateFromString(llmResponse, trace);
        scaledPoint = scaleForImage(pointFromLlm, base64Image);
        if (options?.useCache) {
            (0, cache_1.setInCache)(prompt, base64Image, scaledPoint);
        }
        trace?.update({
            output: scaledPoint,
        });
        generationTrace?.end({
            output: scaledPoint,
        });
    }
    const annotatedImage = await (0, image_1.drawRedDotAtPoint)(base64Image, scaledPoint);
    const dims = (0, image_1.dimensions)(base64Image);
    return {
        x: scaledPoint.x,
        y: scaledPoint.y,
        container: {
            width: dims.width,
            height: dims.height,
        },
        annotatedImage,
    };
}
exports.getCoordinatesFor = getCoordinatesFor;
function scaleForImage(coordinates, base64Image) {
    const { width, height } = (0, image_1.dimensions)(base64Image);
    function sy(value) {
        // Molmo returns coordinates as percentages
        return (value * height) / 100;
    }
    function sx(value) {
        return (value * width) / 100;
    }
    return {
        x: sx(coordinates.x),
        y: sy(coordinates.y),
    };
}
function extractTapCoordinateFromString(inputString, trace) {
    inputString = inputString.trim();
    if (inputString.startsWith('"') && inputString.endsWith('"')) {
        inputString = "'" + inputString.slice(1, -1) + "'";
    }
    if (inputString.includes("<point")) {
        let pattern = /<point x="(\d+.\d+)" y="(\d+.\d+)"/;
        if (inputString.includes("<points")) {
            console.log(`Multi-point response from vision model: ${inputString}`);
            pattern = /<points x1="(\d+.\d+)" y1="(\d+.\d+)"/;
        }
        const match = inputString.match(pattern);
        if (match) {
            const x = parseFloat(match[1]);
            const y = parseFloat(match[2]);
            return {
                x: x,
                y: y,
            };
        }
    }
    throw new Error(`No valid coordinates found in the input string: ${inputString}. ${trace ? `Check the trace for more info: ${trace.getTraceUrl()}` : ""}`);
}
exports.extractTapCoordinateFromString = extractTapCoordinateFromString;
async function getLlmResponse(base64Image, prompt) {
    const url = `${API_BASE_URL}/coordinates`;
    if (!process.env.EMPIRICAL_API_KEY) {
        throw new Error("EMPIRICAL_API_KEY is not set. Please set this environment variable.");
    }
    const response = await (0, async_retry_1.default)(async () => {
        const response = await fetch(url, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Authorization: `${process.env.EMPIRICAL_API_KEY}`,
            },
            body: JSON.stringify({
                content: base64Image,
                prompt,
            }),
        });
        // retry for 5xx by throwing error
        if (!response.ok && response.status >= 500) {
            const errorResponse = await response.text();
            throw new Error(`Failed to get response. status: ${response.status} body: ${errorResponse}`);
        }
        return response;
    }, {
        retries: 3,
        factor: 1,
        minTimeout: 1000,
        randomize: true,
    });
    // handle 4xx errors which are not retried
    if (!response.ok) {
        const errorResponse = await response.text();
        throw new Error(`Failed to get response. status: ${response.status} body: ${errorResponse}`);
    }
    const data = await response.json();
    return data;
}
exports.getLlmResponse = getLlmResponse;
