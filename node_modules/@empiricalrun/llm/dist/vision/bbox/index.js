"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBoundingBox = void 0;
const __1 = require("../..");
const trace_1 = require("../../trace");
const image_1 = require("../image");
const utils_1 = require("../utils");
async function getBoundingBox(base64Image, elementDescription, options = {}) {
    if (!process.env.GOOGLE_API_KEY) {
        throw new Error("Missing GOOGLE_API_KEY: Required for bounding box.");
    }
    const llm = new __1.LLM({
        provider: "google",
        providerApiKey: process.env.GOOGLE_API_KEY,
    });
    if (options?.telemetry?.tags && !trace_1.langfuseInstance) {
        console.warn("Telemetry keys are not set. Telemetry will not be sent.");
    }
    const session = (0, utils_1.getSessionDetails)();
    const trace = trace_1.langfuseInstance?.trace({
        name: "vision-bbox",
        sessionId: session.id,
        release: session.version,
        tags: ["vision", "vision-bbox", ...(options?.telemetry?.tags ?? [])],
    });
    trace?.update({
        input: {
            base64Image,
            elementDescription,
        },
    });
    const temperature = 0.5;
    const model = "gemini-1.5-pro-latest";
    const content = `You are given a screenshot and a description of an element on the screen. You are an expert vision model that can identify bounding box for the element on the screen. Return the output as an array [y_min, x_min, y_max, x_max]. Return only the array and nothing else.\n\nElement description:\n${elementDescription}`;
    const generationTrace = trace?.generation({
        name: "get-bounding-box",
        model,
        modelParameters: {
            temperature,
        },
        input: {
            systemPrompt: content,
            userMessages: {
                image: base64Image,
            },
        },
    });
    const llmResponse = await llm.createChatCompletion({
        messages: [
            {
                role: "system",
                content,
            },
            {
                role: "user",
                content: `Image URL: ${(0, utils_1.imageFormatForProvider)("google", base64Image)}`,
            },
        ],
        model,
        modelParameters: {
            temperature,
        },
    });
    trace?.update({
        output: llmResponse?.content,
    });
    generationTrace?.end({
        output: {
            queryResponse: llmResponse?.content,
        },
    });
    if (!llmResponse) {
        throw new Error(`Failed to get bounding box. Check the trace for more info: ${trace?.getTraceUrl()}`);
    }
    const message = llmResponse.content;
    const arrayAsString = findSubstringWithBrackets(message);
    if (!arrayAsString) {
        throw new Error(`Failed to find array in LLM response: ${message}. Check the trace for more info: ${trace?.getTraceUrl()}`);
    }
    let bbox;
    try {
        const array = sanitizeOutput(arrayAsString);
        bbox = scaleForImage(array, base64Image);
    }
    catch (e) {
        throw new Error(`Failed to parse LLM response: ${message}. Check the trace for more info: ${trace?.getTraceUrl()}`);
    }
    if (options.debug) {
        try {
            bbox.annotatedImage = await (0, image_1.drawBoxOnImage)(base64Image, bbox);
        }
        catch (e) {
            console.warn("Failed to run debug mode for bounding box", e);
        }
    }
    return bbox;
}
exports.getBoundingBox = getBoundingBox;
function scaleForImage(coordinates, base64Image) {
    // Gemini gives responses for 1000x1000, and we need to scale the output
    // Docs: https://ai.google.dev/gemini-api/docs/vision?lang=python#bbox
    const { width, height } = (0, image_1.dimensions)(base64Image);
    const [y_min, x_min, y_max, x_max] = coordinates;
    function sy(value) {
        return (value * height) / 1000;
    }
    function sx(value) {
        return (value * width) / 1000;
    }
    return {
        corners: {
            min: { x: sx(x_min), y: sy(y_min) },
            max: { x: sx(x_max), y: sy(y_max) },
        },
        center: {
            x: sx(x_min + x_max) / 2,
            y: sy(y_min + y_max) / 2,
        },
        container: { width, height },
    };
}
function findSubstringWithBrackets(message) {
    const match = message.match(/\[.*?\]/);
    return match ? match[0] : null;
}
function sanitizeOutput(arrayAsString) {
    // Handle cases like [193 587 245 882], [193, 587, 245, 882], and [193,587,245,882]
    return arrayAsString
        .slice(1, -1)
        .trim()
        .split(/[\s,]+/) // Split by one or more spaces or commas
        .map(Number);
}
