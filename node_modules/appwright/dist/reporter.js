"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const providers_1 = require("./providers");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const fluent_ffmpeg_1 = __importDefault(require("fluent-ffmpeg"));
const ffmpeg_1 = __importDefault(require("@ffmpeg-installer/ffmpeg"));
const logger_1 = require("./logger");
const utils_1 = require("./utils");
const workerInfo_1 = require("./fixture/workerInfo");
class VideoDownloader {
    downloadPromises = [];
    onBegin() {
        if (fs_1.default.existsSync((0, utils_1.basePath)())) {
            fs_1.default.rmSync((0, utils_1.basePath)(), {
                recursive: true,
            });
        }
    }
    onTestBegin(test, result) {
        logger_1.logger.log(`Starting test: ${test.title} on worker ${result.workerIndex}`);
        const workerInfoStore = new workerInfo_1.WorkerInfoStore();
        void workerInfoStore.saveTestStartTime(result.workerIndex, test.title, new Date());
    }
    onTestEnd(test, result) {
        logger_1.logger.log(`Ending test: ${test.title} on worker ${result.workerIndex}`);
        const sessionIdAnnotation = test.annotations.find(({ type }) => type === "sessionId");
        const providerNameAnnotation = test.annotations.find(({ type }) => type === "providerName");
        // Check if test ran on `device` or on `persistentDevice`
        const isTestUsingDevice = sessionIdAnnotation && providerNameAnnotation;
        if (isTestUsingDevice) {
            // This is a test that ran with the `device` fixture
            const sessionId = sessionIdAnnotation.description;
            const providerName = providerNameAnnotation.description;
            const provider = (0, providers_1.getProviderClass)(providerName);
            this.downloadAndAttachDeviceVideo(test, result, provider, sessionId);
            const otherAnnotations = test.annotations.filter(({ type }) => type !== "sessionId" && type !== "providerName");
            test.annotations = otherAnnotations;
        }
        else {
            // This is a test that ran on `persistentDevice` fixture
            const { workerIndex, duration } = result;
            if (duration <= 0) {
                // Skipped tests
                return;
            }
            test.annotations.push({
                type: "workerInfo",
                description: `Ran on worker #${workerIndex}.`,
            });
            const expectedVideoPath = path_1.default.join((0, utils_1.basePath)(), `worker-${workerIndex}-video.mp4`);
            // The `onTestEnd` is method is called before the worker ends and
            // the worker's `endTime` is saved to disk. We add a 5 secs delay
            // to prevent a harmful race condition.
            const workerDownload = waitFiveSeconds()
                .then(() => getWorkerInfo(workerIndex))
                .then(async (workerInfo) => {
                if (!workerInfo) {
                    throw new Error(`Worker info not found for idx: ${workerIndex}`);
                }
                const { providerName, sessionId, endTime } = workerInfo;
                if (!providerName || !sessionId) {
                    throw new Error(`Provider name or session id not found for worker: ${workerIndex}`);
                }
                if (!this.providerSupportsVideo(providerName)) {
                    return; // Nothing to do here
                }
                if (endTime) {
                    // This is the last test in the worker, so let's download the video
                    const provider = (0, providers_1.getProviderClass)(providerName);
                    const downloaded = await provider.downloadVideo(sessionId, (0, utils_1.basePath)(), `worker-${workerIndex}-video`);
                    if (!downloaded) {
                        return;
                    }
                    return this.trimAndAttachPersistentDeviceVideo(test, result, downloaded.path);
                }
                else {
                    // This is an intermediate test in the worker, so let's wait for the
                    // video file to be found on disk. Once it is, we trim and attach it.
                    await waitFor(() => fs_1.default.existsSync(expectedVideoPath));
                    return this.trimAndAttachPersistentDeviceVideo(test, result, expectedVideoPath);
                }
            })
                .catch((e) => {
                logger_1.logger.error("Failed to get worker end time:", e);
            });
            this.downloadPromises.push(workerDownload);
        }
    }
    async onEnd() {
        logger_1.logger.log(`Triggered onEnd`);
        await Promise.allSettled(this.downloadPromises);
    }
    async trimAndAttachPersistentDeviceVideo(test, result, workerVideoPath) {
        const workerIdx = result.workerIndex;
        const workerStart = await getWorkerStartTime(workerIdx);
        let pathToAttach = workerVideoPath;
        const testStart = result.startTime;
        if (testStart.getTime() < workerStart.getTime()) {
            // This is the first test for the worker
            // The startTime for the first test in the worker tends to be
            // before worker (session) start time. This would have been manageable
            // if the `duration` included the worker setup time, but the duration only
            // covers the test method execution time.
            // So in this case, we are not going to trim.
            // TODO: We can use the startTime of the second test in the worker
            pathToAttach = workerVideoPath;
        }
        else {
            const trimSkipPoint = (testStart.getTime() - workerStart.getTime()) / 1000;
            const trimmedFileName = `worker-${workerIdx}-trimmed-${test.id}.mp4`;
            try {
                pathToAttach = await trimVideo({
                    originalVideoPath: workerVideoPath,
                    startSecs: trimSkipPoint,
                    durationSecs: result.duration / 1000,
                    outputPath: trimmedFileName,
                });
            }
            catch (e) {
                logger_1.logger.error("Failed to trim video:", e);
                test.annotations.push({
                    type: "videoError",
                    description: `Unable to trim video, attaching full video instead. Test starts at ${trimSkipPoint} secs.`,
                });
            }
        }
        result.attachments.push({
            path: pathToAttach,
            contentType: "video/mp4",
            name: "video",
        });
    }
    downloadAndAttachDeviceVideo(test, result, providerClass, sessionId) {
        const videoFileName = `${test.id}`;
        if (!providerClass.downloadVideo) {
            return;
        }
        const downloadPromise = providerClass
            .downloadVideo(sessionId, (0, utils_1.basePath)(), videoFileName)
            .then((downloadedVideo) => {
            if (!downloadedVideo) {
                return;
            }
            result.attachments.push({
                ...downloadedVideo,
                name: "video",
            });
            return downloadedVideo;
        });
        this.downloadPromises.push(downloadPromise);
    }
    providerSupportsVideo(providerName) {
        const provider = (0, providers_1.getProviderClass)(providerName);
        return !!provider.downloadVideo;
    }
}
function waitFor(condition, timeout = 60 * 60 * 1000) {
    return new Promise((resolve, reject) => {
        let interval;
        const timeoutId = setTimeout(() => {
            clearInterval(interval);
            reject(new Error("Timed out waiting for condition"));
        }, timeout);
        interval = setInterval(() => {
            if (condition()) {
                clearInterval(interval);
                clearTimeout(timeoutId);
                resolve();
            }
        }, 500);
    });
}
function trimVideo({ originalVideoPath, startSecs, durationSecs, outputPath, }) {
    logger_1.logger.log(`Attemping to trim video: ${originalVideoPath} at start: ${startSecs} and duration: ${durationSecs} to ${outputPath}`);
    const copyName = `draft-for-${outputPath}`;
    const dirPath = path_1.default.dirname(originalVideoPath);
    const copyFullPath = path_1.default.join(dirPath, copyName);
    const fullOutputPath = path_1.default.join(dirPath, outputPath);
    fs_1.default.copyFileSync(originalVideoPath, copyFullPath);
    return new Promise((resolve, reject) => {
        let stdErrs = "";
        (0, fluent_ffmpeg_1.default)(copyFullPath)
            .setFfmpegPath(ffmpeg_1.default.path)
            .setStartTime(startSecs)
            .setDuration(durationSecs)
            .output(fullOutputPath)
            .on("end", () => {
            logger_1.logger.log(`Trimmed video saved at: ${fullOutputPath}`);
            fs_1.default.unlinkSync(copyFullPath);
            resolve(fullOutputPath);
        })
            .on("stderr", (stderrLine) => {
            stdErrs += stderrLine + "\n";
        })
            .on("error", (err) => {
            logger_1.logger.error("ffmpeg error:", err);
            logger_1.logger.error("ffmpeg stderr:", stdErrs);
            reject(err);
        })
            .run();
    });
}
async function getWorkerStartTime(idx) {
    const workerInfoStore = new workerInfo_1.WorkerInfoStore();
    return workerInfoStore.getWorkerStartTime(idx);
}
async function getWorkerInfo(idx) {
    const workerInfoStore = new workerInfo_1.WorkerInfoStore();
    return workerInfoStore.getWorkerFromDisk(idx);
}
const waitFiveSeconds = () => new Promise((resolve) => setTimeout(resolve, 5000));
exports.default = VideoDownloader;
