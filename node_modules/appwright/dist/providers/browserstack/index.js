"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserStackDeviceProvider = void 0;
const async_retry_1 = __importDefault(require("async-retry"));
const fs_1 = __importDefault(require("fs"));
const form_data_1 = __importDefault(require("form-data"));
const path_1 = __importDefault(require("path"));
const device_1 = require("../../device");
const logger_1 = require("../../logger");
const API_BASE_URL = "https://api-cloud.browserstack.com/app-automate";
const envVarKeyForBuild = (projectName) => `BROWSERSTACK_APP_URL_${projectName.toUpperCase()}`;
function getAuthHeader() {
    const userName = process.env.BROWSERSTACK_USERNAME;
    const accessKey = process.env.BROWSERSTACK_ACCESS_KEY;
    const key = Buffer.from(`${userName}:${accessKey}`).toString("base64");
    return `Basic ${key}`;
}
async function getSessionDetails(sessionId) {
    const response = await fetch(`${API_BASE_URL}/sessions/${sessionId}.json`, {
        method: "GET",
        headers: {
            Authorization: getAuthHeader(),
        },
    });
    if (!response.ok) {
        throw new Error(`Error fetching session details: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
}
class BrowserStackDeviceProvider {
    sessionDetails;
    sessionId;
    project;
    constructor(project, appBundleId) {
        this.project = project;
        if (appBundleId) {
            logger_1.logger.log(`Bundle id is specified (${appBundleId}) but ignored for BrowserStack provider.`);
        }
    }
    async globalSetup() {
        if (!this.project.use.buildPath) {
            throw new Error(`Build path not found. Please set the build path in the config file.`);
        }
        if (!(process.env.BROWSERSTACK_USERNAME && process.env.BROWSERSTACK_ACCESS_KEY)) {
            throw new Error("BROWSERSTACK_USERNAME and BROWSERSTACK_ACCESS_KEY are required environment variables for this device provider.");
        }
        const buildPath = this.project.use.buildPath;
        const isHttpUrl = buildPath.startsWith("http");
        const isBrowserStackUrl = buildPath.startsWith("bs://");
        let appUrl = undefined;
        if (isBrowserStackUrl) {
            appUrl = buildPath;
        }
        else {
            // Upload the file to BrowserStack and get the appUrl
            let body;
            let headers = {
                Authorization: getAuthHeader(),
            };
            if (isHttpUrl) {
                body = new URLSearchParams({
                    url: buildPath,
                });
            }
            else {
                if (!fs_1.default.existsSync(buildPath)) {
                    throw new Error(`Build file not found: ${buildPath}`);
                }
                const form = new form_data_1.default();
                form.append("file", fs_1.default.createReadStream(buildPath));
                headers = { ...headers, ...form.getHeaders() };
                body = form;
            }
            const fetch = (await import("node-fetch")).default;
            logger_1.logger.log(`Uploading: ${buildPath}`);
            const response = await fetch(`${API_BASE_URL}/upload`, {
                method: "POST",
                headers,
                body,
            });
            const data = await response.json();
            appUrl = data.app_url;
            if (!appUrl) {
                logger_1.logger.error("Uploading the build failed:", data);
            }
        }
        process.env[envVarKeyForBuild(this.project.name)] = appUrl;
    }
    async getDevice() {
        this.validateConfig();
        const config = this.createConfig();
        return await this.createDriver(config);
    }
    validateConfig() {
        const device = this.project.use.device;
        if (!device.name || !device.osVersion) {
            throw new Error("Device name and osVersion are required for running tests on BrowserStack");
        }
    }
    async createDriver(config) {
        const WebDriver = (await import("webdriver")).default;
        const webDriverClient = await WebDriver.newSession(config);
        this.sessionId = webDriverClient.sessionId;
        const bundleId = await this.getAppBundleIdFromSession();
        const testOptions = {
            expectTimeout: this.project.use.expectTimeout,
        };
        return new device_1.Device(webDriverClient, bundleId, testOptions, this.project.use.device?.provider);
    }
    async getSessionDetails() {
        const data = await getSessionDetails(this.sessionId);
        this.sessionDetails = data.automation_session;
    }
    async getAppBundleIdFromSession() {
        await this.getSessionDetails();
        return this.sessionDetails?.app_details.app_name ?? "";
    }
    static async downloadVideo(sessionId, outputDir, fileName) {
        const sessionData = await getSessionDetails(sessionId);
        const sessionDetails = sessionData?.automation_session;
        const videoURL = sessionDetails?.video_url;
        const pathToTestVideo = path_1.default.join(outputDir, `${fileName}.mp4`);
        const tempPathForWriting = `${pathToTestVideo}.part`;
        const dir = path_1.default.dirname(pathToTestVideo);
        fs_1.default.mkdirSync(dir, { recursive: true });
        /**
         * The BrowserStack video URL initially returns a 200 status,
         * but the video file may still be empty. To avoid downloading
         * an incomplete file, we introduce a delay of 10_000 ms before attempting the download.
         * After the wait, BrowserStack may return a 403 error if the video is not
         * yet available. We handle this by retrying the download until we either
         * receive a 200 response (indicating the video is ready) or reach a maximum
         * of 10 retries, whichever comes first.
         */
        await new Promise((resolve) => setTimeout(resolve, 10_000));
        const fileStream = fs_1.default.createWriteStream(tempPathForWriting);
        //To catch the browserstack error in case all retries fails
        try {
            if (videoURL) {
                await (0, async_retry_1.default)(async () => {
                    const response = await fetch(videoURL, {
                        method: "GET",
                    });
                    if (response.status !== 200) {
                        // Retry if not 200
                        throw new Error(`Video not found: ${response.status} (URL: ${videoURL})`);
                    }
                    const reader = response.body?.getReader();
                    if (!reader) {
                        throw new Error("Failed to get reader from response body.");
                    }
                    const streamToFile = async () => {
                        // eslint-disable-next-line no-constant-condition
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done)
                                break;
                            fileStream.write(value);
                        }
                    };
                    await streamToFile();
                    fileStream.close();
                }, {
                    retries: 10,
                    minTimeout: 3_000,
                    onRetry: (err, i) => {
                        if (i > 5) {
                            logger_1.logger.warn(`Retry attempt ${i} failed: ${err.message}`);
                        }
                    },
                });
                return new Promise((resolve, reject) => {
                    // Ensure file stream is closed even in case of an error
                    fileStream.on("finish", () => {
                        try {
                            fs_1.default.renameSync(tempPathForWriting, pathToTestVideo);
                            logger_1.logger.log(`Download finished and file closed: ${pathToTestVideo}`);
                            resolve({ path: pathToTestVideo, contentType: "video/mp4" });
                        }
                        catch (err) {
                            logger_1.logger.error(`Failed to rename file: `, err);
                            reject(err);
                        }
                    });
                    fileStream.on("error", (err) => {
                        logger_1.logger.error(`Failed to write file: ${err.message}`);
                        reject(err);
                    });
                });
            }
            else {
                return null;
            }
        }
        catch (e) {
            logger_1.logger.log(`Error Downloading video: `, e);
            return null;
        }
    }
    async syncTestDetails(details) {
        const response = await fetch(`${API_BASE_URL}/sessions/${this.sessionId}.json`, {
            method: "PUT",
            headers: {
                Authorization: getAuthHeader(),
                "Content-Type": "application/json",
            },
            body: details.status
                ? JSON.stringify({
                    status: details.status,
                    reason: details.reason,
                })
                : JSON.stringify({
                    name: details.name,
                }),
        });
        if (!response.ok) {
            throw new Error(`Error setting session details: ${response.statusText}`);
        }
        const responseData = await response.json();
        return responseData;
    }
    createConfig() {
        const platformName = this.project.use.platform;
        const projectName = path_1.default.basename(process.cwd());
        const envVarKey = envVarKeyForBuild(this.project.name);
        if (!process.env[envVarKey]) {
            throw new Error(`process.env.${envVarKey} is not set. Did the file upload work?`);
        }
        return {
            port: 443,
            path: "/wd/hub",
            protocol: "https",
            logLevel: "warn",
            user: process.env.BROWSERSTACK_USERNAME,
            key: process.env.BROWSERSTACK_ACCESS_KEY,
            hostname: "hub.browserstack.com",
            capabilities: {
                "bstack:options": {
                    debug: true,
                    interactiveDebugging: true,
                    networkLogs: true,
                    appiumVersion: "2.6.0",
                    enableCameraImageInjection: this.project.use.device?.enableCameraImageInjection,
                    idleTimeout: 180,
                    deviceName: this.project.use.device?.name,
                    osVersion: this.project.use.device.osVersion,
                    platformName: platformName,
                    deviceOrientation: this.project.use.device?.orientation,
                    buildName: `${projectName} ${platformName}`,
                    sessionName: `${projectName} ${platformName} test`,
                    buildIdentifier: process.env.GITHUB_ACTIONS === "true"
                        ? `CI ${process.env.GITHUB_RUN_ID}`
                        : process.env.USER,
                },
                "appium:autoGrantPermissions": true,
                "appium:app": process.env[envVarKey],
                "appium:autoAcceptAlerts": true,
                "appium:fullReset": true,
                "appium:settings[snapshotMaxDepth]": 62,
            },
        };
    }
}
exports.BrowserStackDeviceProvider = BrowserStackDeviceProvider;
