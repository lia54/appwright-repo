"use strict";
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Device = void 0;
const locator_1 = require("../locator");
const types_1 = require("../types");
const vision_1 = require("../vision");
const utils_1 = require("../utils");
const utils_2 = require("../providers/browserstack/utils");
const utils_3 = require("../providers/lambdatest/utils");
const logger_1 = require("../logger");
let Device = (() => {
    let _instanceExtraInitializers = [];
    let _tap_decorators;
    let _terminateApp_decorators;
    let _activateApp_decorators;
    let _getClipboardText_decorators;
    let _setMockCameraView_decorators;
    let _pause_decorators;
    let _waitForTimeout_decorators;
    let _screenshot_decorators;
    let _scroll_decorators;
    let _sendKeyStrokes_decorators;
    return class Device {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _tap_decorators = [utils_1.boxedStep];
            _terminateApp_decorators = [utils_1.boxedStep];
            _activateApp_decorators = [utils_1.boxedStep];
            _getClipboardText_decorators = [utils_1.boxedStep];
            _setMockCameraView_decorators = [utils_1.boxedStep];
            _pause_decorators = [utils_1.boxedStep];
            _waitForTimeout_decorators = [utils_1.boxedStep];
            _screenshot_decorators = [utils_1.boxedStep];
            _scroll_decorators = [utils_1.boxedStep];
            _sendKeyStrokes_decorators = [utils_1.boxedStep];
            __esDecorate(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: obj => "tap" in obj, get: obj => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _terminateApp_decorators, { kind: "method", name: "terminateApp", static: false, private: false, access: { has: obj => "terminateApp" in obj, get: obj => obj.terminateApp }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _activateApp_decorators, { kind: "method", name: "activateApp", static: false, private: false, access: { has: obj => "activateApp" in obj, get: obj => obj.activateApp }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _getClipboardText_decorators, { kind: "method", name: "getClipboardText", static: false, private: false, access: { has: obj => "getClipboardText" in obj, get: obj => obj.getClipboardText }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setMockCameraView_decorators, { kind: "method", name: "setMockCameraView", static: false, private: false, access: { has: obj => "setMockCameraView" in obj, get: obj => obj.setMockCameraView }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _pause_decorators, { kind: "method", name: "pause", static: false, private: false, access: { has: obj => "pause" in obj, get: obj => obj.pause }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _waitForTimeout_decorators, { kind: "method", name: "waitForTimeout", static: false, private: false, access: { has: obj => "waitForTimeout" in obj, get: obj => obj.waitForTimeout }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: obj => "screenshot" in obj, get: obj => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _scroll_decorators, { kind: "method", name: "scroll", static: false, private: false, access: { has: obj => "scroll" in obj, get: obj => obj.scroll }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _sendKeyStrokes_decorators, { kind: "method", name: "sendKeyStrokes", static: false, private: false, access: { has: obj => "sendKeyStrokes" in obj, get: obj => obj.sendKeyStrokes }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        webDriverClient = __runInitializers(this, _instanceExtraInitializers);
        bundleId;
        timeoutOpts;
        provider;
        constructor(webDriverClient, bundleId, timeoutOpts, provider) {
            this.webDriverClient = webDriverClient;
            this.bundleId = bundleId;
            this.timeoutOpts = timeoutOpts;
            this.provider = provider;
        }
        locator({ selector, findStrategy, textToMatch, }) {
            return new locator_1.Locator(this.webDriverClient, this.timeoutOpts, selector, findStrategy, textToMatch);
        }
        vision() {
            return new vision_1.VisionProvider(this, this.webDriverClient);
        }
        beta = {
            tap: async (prompt, options) => {
                return await this.vision().tap(prompt, options);
            },
            query: async (prompt, options) => {
                return await this.vision().query(prompt, options);
            },
        };
        /**
         * Closes the automation session. This is called automatically after each test.
         *
         * **Usage:**
         * ```js
         * await device.close();
         * ```
         */
        async close() {
            // TODO: Add @boxedStep decorator here
            // Disabled because it breaks persistentDevice as test.step will throw as test is
            // undefined when the function is called
            try {
                await this.webDriverClient.deleteSession();
            }
            catch (e) {
                logger_1.logger.error(`close:`, e);
            }
        }
        /**
         * Tap on the screen at the given coordinates, specified as x and y. The top left corner
         * of the screen is { x: 0, y: 0 }.
         *
         * **Usage:**
         * ```js
         * await device.tap({ x: 100, y: 100 });
         * ```
         *
         * @param coordinates to tap on
         * @returns
         */
        async tap({ x, y }) {
            if (this.getPlatform() == types_1.Platform.ANDROID) {
                await this.webDriverClient.executeScript("mobile: clickGesture", [
                    {
                        x: x,
                        y: y,
                        duration: 100,
                        tapCount: 1,
                    },
                ]);
            }
            else {
                await this.webDriverClient.executeScript("mobile: tap", [
                    {
                        x: x,
                        y: y,
                    },
                ]);
            }
        }
        /**
         * Locate an element on the screen with text content. This method defaults to a
         * substring match, and this be overridden by setting the `exact` option to `true`.
         *
         * **Usage:**
         * ```js
         * // with string
         * const submitButton = device.getByText("Submit");
         *
         * // with RegExp
         * const counter = device.getByText(/^Counter: \d+/);
         * ```
         *
         * @param text string or regular expression to search for
         * @param options
         * @returns
         */
        getByText(text, { exact = false } = {}) {
            const isAndroid = this.getPlatform() == types_1.Platform.ANDROID;
            if (text instanceof RegExp) {
                const substringForContains = (0, utils_1.longestDeterministicGroup)(text);
                if (!substringForContains) {
                    return this.locator({
                        selector: "//*",
                        findStrategy: "xpath",
                        textToMatch: text,
                    });
                }
                else {
                    const selector = isAndroid
                        ? `textContains("${substringForContains}")`
                        : `label CONTAINS "${substringForContains}"`;
                    return this.locator({
                        selector: selector,
                        findStrategy: isAndroid
                            ? "-android uiautomator"
                            : "-ios predicate string",
                        textToMatch: text,
                    });
                }
            }
            let path;
            if (isAndroid) {
                path = exact ? `text("${text}")` : `textContains("${text}")`;
            }
            else {
                path = exact ? `label == "${text}"` : `label CONTAINS "${text}"`;
            }
            return this.locator({
                selector: path,
                findStrategy: isAndroid
                    ? "-android uiautomator"
                    : "-ios predicate string",
                textToMatch: text,
            });
        }
        /**
         * Locate an element on the screen with accessibility identifier. This method defaults to
         * a substring match, and this can be overridden by setting the `exact` option to `true`.
         *
         * **Usage:**
         * ```js
         * const element = await device.getById("signup_button");
         * ```
         *
         * @param text string to search for
         * @param options
         * @returns
         */
        getById(text, { exact = false } = {}) {
            const isAndroid = this.getPlatform() == types_1.Platform.ANDROID;
            let path;
            if (isAndroid) {
                path = exact ? `resourceId("${text}")` : `resourceIdMatches("${text}")`;
            }
            else {
                path = exact ? `name == "${text}"` : `name CONTAINS "${text}"`;
            }
            return this.locator({
                selector: path,
                findStrategy: isAndroid
                    ? "-android uiautomator"
                    : "-ios predicate string",
                textToMatch: text,
            });
        }
        /**
         * Locate an element on the screen with xpath.
         *
         * **Usage:**
         * ```js
         * const element = await device.getByXpath(`//android.widget.Button[@text="Confirm"]`);
         * ```
         *
         * @param xpath xpath to locate the element
         * @returns
         */
        getByXpath(xpath) {
            return this.locator({ selector: xpath, findStrategy: "xpath" });
        }
        /**
         * Helper method to detect the mobile OS running on the device.
         *
         * **Usage:**
         * ```js
         * const platform = device.getPlatform();
         * ```
         *
         * @returns "android" or "ios"
         */
        getPlatform() {
            const isAndroid = this.webDriverClient.isAndroid;
            return isAndroid ? types_1.Platform.ANDROID : types_1.Platform.IOS;
        }
        async terminateApp(bundleId) {
            if (!this.bundleId && !bundleId) {
                throw new Error("bundleId is required to terminate the app.");
            }
            const keyName = this.getPlatform() == types_1.Platform.ANDROID ? "appId" : "bundleId";
            await this.webDriverClient.executeScript("mobile: terminateApp", [
                {
                    [keyName]: bundleId || this.bundleId,
                },
            ]);
        }
        async activateApp(bundleId) {
            if (!this.bundleId && !bundleId) {
                throw new Error("bundleId is required to activate the app.");
            }
            const keyName = this.getPlatform() == types_1.Platform.ANDROID ? "appId" : "bundleId";
            await this.webDriverClient.executeScript("mobile: activateApp", [
                {
                    [keyName]: bundleId || this.bundleId,
                },
            ]);
        }
        /**
         * Retrieves text content from the clipboard of the mobile device. This is useful
         * after a "copy to clipboard" action has been performed. This returns base64 encoded string.
         *
         * **Usage:**
         * ```js
         * const clipboardText = await device.getClipboardText();
         * ```
         *
         * @returns Returns the text content of the clipboard in base64 encoded string.
         */
        async getClipboardText() {
            if (this.getPlatform() == types_1.Platform.ANDROID) {
                return await this.webDriverClient.getClipboard();
            }
            else {
                if (this.provider == "emulator") {
                    // iOS simulator supports clipboard sharing
                    return await this.webDriverClient.getClipboard();
                }
                else {
                    if (!this.bundleId) {
                        throw new Error("bundleId is required to retrieve clipboard data on a real device.");
                    }
                    await this.activateApp("com.facebook.WebDriverAgentRunner.xctrunner");
                    const clipboardDataBase64 = await this.webDriverClient.getClipboard();
                    await this.activateApp(this.bundleId);
                    return clipboardDataBase64;
                }
            }
        }
        /**
         * Sets a mock camera view using the specified image. This injects a mock image into the camera view.
         * Currently, this functionality is supported only for BrowserStack.
         *
         * **Usage:**
         * ```js
         * await device.setMockCameraView(`screenshot.png`);
         * ```
         *
         * @param imagePath path to the image file that will be used as the mock camera view.
         * @returns
         */
        async setMockCameraView(imagePath) {
            if (this.provider == "browserstack") {
                const imageURL = await (0, utils_2.uploadImageToBS)(imagePath);
                await this.webDriverClient.executeScript(`browserstack_executor: {"action":"cameraImageInjection", "arguments": {"imageUrl" : "${imageURL}"}}`, []);
            }
            else if (this.provider == "lambdatest") {
                const imageURL = await (0, utils_3.uploadImageToLambdaTest)(imagePath);
                await this.webDriverClient.executeScript(`lambda-image-injection=${imageURL}`, []);
            }
        }
        async pause() {
            const skipPause = process.env.CI === "true";
            if (skipPause) {
                return;
            }
            logger_1.logger.log(`device.pause: Use Appium Inspector to attach to the session.`);
            let iterations = 0;
            // eslint-disable-next-line no-constant-condition
            while (true) {
                await new Promise((resolve) => setTimeout(resolve, 20_000));
                await this.webDriverClient.takeScreenshot();
                iterations += 1;
                if (iterations % 3 === 0) {
                    logger_1.logger.log(`device.pause: ${iterations * 20} secs elapsed.`);
                }
            }
        }
        async waitForTimeout(timeout) {
            await new Promise((resolve) => setTimeout(resolve, timeout));
        }
        /**
         * Get a screenshot of the current screen as a base64 encoded string.
         */
        async screenshot() {
            return await this.webDriverClient.takeScreenshot();
        }
        /**
         * [iOS Only]
         * Scroll the screen from 0.2 to 0.8 of the screen height.
         * This can be used for controlled scroll, for auto scroll checkout `scroll` method from locator.
         *
         * **Usage:**
         * ```js
         * await device.scroll();
         * ```
         *
         */
        async scroll() {
            const driverSize = await this.webDriverClient.getWindowRect();
            // Scrolls from 0.8 to 0.2 of the screen height
            const from = { x: driverSize.width / 2, y: driverSize.height * 0.8 };
            const to = { x: driverSize.width / 2, y: driverSize.height * 0.2 };
            await this.webDriverClient.executeScript("mobile: dragFromToForDuration", [
                { duration: 2, fromX: from.x, fromY: from.y, toX: to.x, toY: to.y },
            ]);
        }
        /**
         * Send keys to already focused input field.
         * To fill input fields using the selectors use `sendKeyStrokes` method from locator
         */
        async sendKeyStrokes(value) {
            const actions = value
                .split("")
                .map((char) => [
                { type: "keyDown", value: char },
                { type: "keyUp", value: char },
            ])
                .flat();
            await this.webDriverClient.performActions([
                {
                    type: "key",
                    id: "keyboard",
                    actions: actions,
                },
            ]);
            await this.webDriverClient.releaseActions();
        }
    };
})();
exports.Device = Device;
